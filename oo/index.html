<html>
  <head>
    <link rel="stylesheet" href="resources/codemirror.css"></link>
    <link rel="stylesheet" href="resources/common.css"></link>
    <link rel="stylesheet" href="resources/tests.css"></link>
    <link rel="stylesheet" href="resources/playground.css"></link>

    <script src="resources/helpers.js"></script>
    <script src="resources/lang.js"></script>
    <script src="resources/tests.js"></script>
    <script src="resources/IndentingOutputStream.js"></script>
    <script src="resources/playground.js"></script>
    <script src="resources/beautify.js"></script>

    <script src="resources/jquery-2.1.1.min.js"></script>
    <script src="resources/codemirror.js"></script>

    <script type="text/ohm-js">

O {
  Program
    = ProgramPart* Expr?

  ProgramPart
    = ClassDecl
    | MethodDecl
    | Stmt

  ClassDecl
    = class className (extends className)? InstVarDecls ';'

  InstVarDecls
    = with ident (',' ident)*  -- some
    |                          -- none

  MethodDecl
    = def className '.' ident Formals MethodBody  -- nary1
    | def className (ident ident)+ MethodBody     -- nary2
    | def className binSelector ident MethodBody  -- binary

  MethodBody
    = '=' Expr ';'         -- expr
    | '{' Stmt* Expr? '}'  -- stmt

  Stmt
    = var VarDeclPart (',' VarDeclPart)* ';'  -- varDecls
    | return Expr ';'                         -- return
    | this '.' ident '=' Expr ';'             -- instVarAssign
    | ident '=' Expr ';'                      -- varAssign
    | Expr ';'                                -- expr

  VarDeclPart
    = ident '=' Expr  -- init
    | ident           -- noInit

  Expr  -- expression
    = WSendExpr

  WSendExpr
    = super  (ident EqExpr)+  -- super
    | EqExpr (ident EqExpr)+  -- send
    | EqExpr

  EqExpr
    = RelExpr ('===' | '==' | '!==' | '!=') RelExpr  -- eq
    | RelExpr

  OrExpr
    = OrExpr or AndExpr  -- or
    | AndExpr

  AndExpr
    = AndExpr and RelExpr  -- and
    | RelExpr

  RelExpr
    = AddExpr ('<=' | '<' | '>=' | '>') AddExpr  -- rel
    | AddExpr

  AddExpr
    = AddExpr ('+' | '-') MulExpr  -- add
    | MulExpr

  MulExpr
    = MulExpr ('*' | '/' | '%') DotExpr  -- mul
    | DotExpr

  DotExpr
    = super   '.' ident Actuals  -- super
    | DotExpr '.' ident Actuals  -- send
    | this    '.' ident  ~'('    -- instVarAccess
    | UnExpr

  UnExpr
    = '+' PriExpr  -- pos
    | '-' PriExpr  -- neg
    | PriExpr

  PriExpr
    = '(' Expr ')'                  -- paren
    | '{' BFormals Stmt* Expr? '}'  -- block
    | new className Actuals         -- new
    | string                        -- str
    | ident                         -- ident
    | number                        -- number
    | this                          -- this
    | trueK                         -- true
    | falseK                        -- false
    | nullK                         -- null

  Actuals
    = '(' ')'                   -- none
    | '(' Expr (',' Expr)* ')'  -- some

  Formals
    = '(' ')'                     -- none
    | '(' ident (',' ident)* ')'  -- some

  BFormals
    = ident (',' ident)* '|'  -- some
    |                         -- none

  ident  -- identifier
    = ~keyword lower alnum*

  className  -- class name
    = upper alnum*

  string  -- string literal
    = '"' (~'"' ~'\n' _)* '"'

  number  -- number literal
    = digit+ ('.' digit+)?  -- wholeAndFrac
    | '.' digit+            -- onlyFrac

  binSelector  -- binary selector
    = '===' | '==' | '!==' | '!=' | '<=' | '<' | '>=' | '>'
    | '+'   | '-'  | '*'   | '/'  | '%'

  and        = 'and' ~alnum
  class      = 'class' ~alnum
  def        = 'def' ~alnum
  extends    = 'extends' ~alnum
  falseK     = 'false' ~alnum
  new        = 'new' ~alnum
  nullK      = 'null' ~alnum
  or         = 'or' ~alnum
  return     = 'return' ~alnum
  super      = 'super' ~alnum
  this       = 'this' ~alnum
  trueK      = 'true' ~alnum
  var        = 'var' ~alnum
  with       = 'with' ~alnum

  space += comment

  comment
    = '/*' (~'*/' _)* '*/'          -- multiLine
    | '//' (~'\n' _)* ('\n' | end)  -- singleLine

  keyword = class | def  | extends | falseK | new  | nullK  | return
          | super | this | trueK   | var    | with

  tokens = (keyword | ident | comment | _)*
}

    </script>
    <script src="resources/ohm.min.js"></script>
    <script src="O.js"></script>
    <script src="prettyPrint.js"></script>
  </head>
  <body>
    <everything>
      <header>
        <part>Part III:</part>
        <descr>Object-Oriented Programming</descr>
        <detail>(source-to-source translator)</detail>
      </header>
      <abstract>
        In Part III of this class, we will "prototype" an object-oriented programming language using
        a technique known as <i>source-to-source translation</i>.
      </abstract>
      <section>
        <sectionHeader>
          <span>Introduction</span>
        </sectionHeader>
        <p>
          So far we've seen two common ways to prototype a programming language: as a stand-alone interpreter and as a
          library (or <i>embedded language</i>) in an existing host language. In this part of the class we'll see a
          third common implementation style that involves translating a program in the <i>source language</i> into a
          program in an existing language (the <i>target language</i>) that has the desired behavior. Such a
          <i>source-to-source translation</i> can be viewed as a lightweight form of compilation: rather than
          translating all the way down to machine code, the language implementer gets to leverage the features in a
          high-level target language, which significantly simplifies the task.
        </p>
        <p>
          This approach can also be seen as a middle ground between the two prior approaches we've seen in the class.
          Like with an interpreter, the source language has its own syntax (and requires a parser to convert this
          syntax into some form of abstract syntax trees). Like with an embedded language, it's often possible to
          represent features in the source language directly, using counterparts in the target language. For example, it
          might be possible to translate a function in the source language to a function in the target language that
          has the same behavior, which then allows function calls in the source language to be implemented simply as
          function calls in the target language.
        </p>
        <p>
          Of course, some language features in the source language will not map directly to a semantically-equivalent
          construct in the target language. In that case, the translation has to construct some code in the target
          language that will behave as desired. Depending on the complexity of that code, it may be nicer to factor it
          out to a library so that the target code is as simple and readable as possible. Such a library is similar in
          spirit to the idea of an embedded language that we saw in the previous homework assignment, except that this
          library is meant only for use by the source-to-source translator rather than directly by the programmer.
        </p>
        <p>
          In Part III of this class, you'll "prototype" an object-oriented programming language by translating it to
          JavaScript. In Homework #4, you will write a library that implements the core semantics of classes and
          objects in our source language. In Homework #5, you will write a translator that completes the prototype and
          also add some interesting new features to the language.
        </p>
      </section>
      <section>
        <sectionHeader>
          <span>Our OO Language</span>
        </sectionHeader>
        <p>
          We'll start with a "vanilla" object-oriented language with single inheritance. Our language is
          dynamically-typed, and has Java-like syntax.
        </p>
        <h2>Declaring Classes</h2>
        <p>
          Here's how you declare a new class in our language:
	  <codeBlock>class Point with x, y;</codeBlock>
          The <code>Point</code> class in this example has two instance variables, <code>x</code> and <code>y</code>.
          (Instance variables are declared using the <code>var</code> keyword.)
        </p>
        <p>
          By default, new classes are subclasses of <code>Object</code>, which is the root of the class hierarchy in
          our language. You can optionally specify a superclass in a class declaration using  the <code>extends</code>
          keyword, e.g.,<codeBlock>class ThreeDeePoint extends Point with z;</codeBlock>
        </p>
        <h2>Declaring Methods</h2>
        <p>
          Our language supports <i>open classes</i>. This means that you can add new methods to a class without
          editing its declaration. In fact, the syntax of our language does not even allow programmers to write methods
          as part of a class declaration. Here's how you add a method called <code>initialize</code> with arguments
          <code>x</code> and <code>y</code> to our <code>Point</code> class:<codeBlock>def Point.initialize(x, y) {
  this.x = x;
  this.y = y;
}</codeBlock>
          And here's how you override <code>Point</code>'s <code>initialize</code> method shown above for instances
          of <code>ThreeDeePoint</code>:<codeBlock>def ThreeDeePoint.initialize(x, y, z) {
  super.initialize(x, y);
  this.z = z;
}
</codeBlock>
          <b>Note:</b> In our language, it doesn't matter that <code>ThreeDeePoint</code>'s version of
          <code>initialize</code> takes 3 arguments whereas <code>Point</code>'s <code>initialize</code> method only
          takes two arguments &mdash; the former still overrides the latter. (Our language does not support static
          overloading.)
        </p>
        <h2>Creating Objects</h2>
        <p>
          To create a new instance of a class, you use the <code>new</code> keyword:
          <codeBlock>var p = new Point(1, 2);</codeBlock>
          As part of evaluating a <code>new</code> expression, our language invokes the <code>initialize</code> method
          on the new instance with the arguments supplied. Here's what happens when the expression
          <code>new C(arg<sub>1</sub>, arg<sub>2</sub>, &hellip;)</code> is evaluated:
          <ul>
            <li>A new instance of <code>C</code> is created;</li>
            <li>The new instance's <code>initialize</code> method is called with the arguments provided, i.e.,
              <code>newInstance.initialize(arg<sub>1</sub>, arg<sub>2</sub>, &hellip;)</code>;</li>
            <li>The new instance becomes the value of the entire <code>new</code> expression.</li>
          </ul>
        </p>
        <h2>Statements and Expressions</h2>
        <p>
          Our language supports typical kinds of statements and expressions that you find in an OO language, most
          importantly the abilities to send a message to an object, access the value of an instance variable of an
          object, and update the value of an instance variable of an object. The <code>initialize</code> methods above
          illustrate assignment to instance variables, for example. These constructs should have the same behavior as
          they do in a typical OO language such as Java.
        </p>
        <p>
          In homework #4, method bodies can additionally employ JavaScript primitive values and associated
          operations, along with control-flow statements like conditionals and loops. In homework #5
          we will see how our source language supports these things (and more!) in an elegant and powerful way.
        </p>
      </section>
      <section>
        <sectionHeader>
          <span>Homework #4: A Library for Classes and Objects</span>
        </sectionHeader>
        <p>
          <due>
            <b>Due at 11:30pm on Friday, February 20.</b>
            Turn in just your <tt>oo.js</tt> file through the course page on CCLE.
          </due>
        </p>
        <p>
          In this homework assignment, you will implement a library containing the core functionality that will be
          necessary for the translation of our OO language to JavaScript.  This homework assignment has two parts,
          described below.
        </p>
        <p>
          <b>Important:</b> Please do your work in a file called <a href="oo.js"><code>oo.js</code></a>. Each time you
          refresh this page, that file is loaded by our test harness to run the unit tests on this page. As in the
          previous homework assignments, you can add your own test cases by editing
          <a href="hw4-tests-part1.js"><code>hw4-tests-part1.js</code></a> and
          <a href="hw4-tests-part2.js"><code>hw4-tests-part2.js</code></a>.
        </p>
        <h2>Part I: The Library</h2>
        <p>
          Your library, which will be accessed via the global variable <code>OO</code>, will maintain a
          <i>class table</i> that maps class names to their associated classes. This means that you will have to come
          up with an appropriate representation of classes. You will also have to decide how to represent
          instances of those classes. Your library must support all of the methods described below:
          <ul>
            <li>
              <code>initializeCT()</code>
              <ul>
                <li>Initializes the class table. After this method is called, the class table should only contain the
                  <code>Object</code> class, which must support the following methods:
                  <ul>
                    <li><code>initialize()</code>, which does nothing.
                    <li><code>=== x</code>, which returns <code>true</code> if the receiver and <code>x</code> are
                      the same object, <code>false</code> otherwise.<br>
                      (This method has the same semantics as JavaScript's <code>===</code> operator.)</li>
                    <li><code>!== x</code>, which returns <code>true</code> if the receiver and <code>x</code> are
                      <b>not</b> the same object, <code>false</code> otherwise.<br>
                      (This method has the same semantics as JavaScript's <code>!==</code> operator.)</li>
                  </ul>
                  (See <code>declareMethod</code> below for more on the representation of methods.)</li>
              </ul>
            </li>
            <li>
              <code>declareClass(name, superClassName, instVarNames)</code>
              <ul>
                <li>Creates a new class with the appropriate name, superclass, and instance variable names, and adds
                  that class to the class table.
                <li>Throws an exception if:
                  <ul>
                    <li>The class table already contains a class with the same name
                      (<i>duplicate class declaration</i>).</li>
                    <li>There is no entry in the class table for <code>superClassName</code>
                      (<i>undeclared class</i>).</li>
                    <li>There are duplicates in <code>instVarNames</code>, or one or more elements of
                      <code>instVarNames</code> are also instance variable names of a (possibly transitive) superclass
                      (<i>duplicate instance variable declaration</i>).</li>
                  </ul>
                </li>
                <li>E.g., <code>OO.declareClass("Point", "Object", ["x", "y"])</code></li>
              </ul>
            </li>
            <li>
              <code>declareMethod(className, selector, implFn)</code>
              <ul>
                <li>Adds a method named <code>selector</code> to the class named <code>className</code>, whose
                  associated method implementation is <code>implFn</code>.</li>
                <li>The implementation function <code>implFn</code> should have <code>_this</code> as its first
                  argument, followed by the formal arguments of the method that is being declared. (When a method
                  is called, <code>_this</code> will be bound to the receiver.) E.g.,
                  <codeBlock>OO.declareMethod("Point", "initialize",
  function(_this, x, y) {
    OO.setInstVar(_this, "x", x);
    OO.setInstVar(_this, "y", y);
  }
);</codeBlock>
and <codeBlock>OO.declareMethod("Point", "+",
  function(_this, that) {
    return OO.instantiate(
      "Point",
      OO.send(OO.getInstVar(_this, "x"), "+", send(that, "getX")),
      OO.send(OO.getInstVar(_this, "y"), "+", send(that, "getY"))
    );
  }
);</codeBlock></li>
                <li>Note that <code>declareMethod</code> can also be used to override a method of the same
                  name in the superclass.</li>
              </ul>
            </li>
            <li>
              <code>instantiate(className, arg<sub>1</sub>, arg<sub>2</sub>, &hellip;)</code>
              <ul>
                <li>Creates a new instance of the class named <code>className</code>, calls its <code>initialize</code>
                   method with <code>arg<sub>1</sub></code>, <code>arg<sub>2</sub></code>, &hellip; as arguments, and
                   returns the new instance.</li>
                <li>Throws an exception if there is no entry in the class table for <code>className</code>
                  (<i>undeclared class</i>).</li>
                <li>E.g., <code>OO.instantiate("Point", 1, 2)</code> should evaluate to a new <code>Point</code> whose
                  <code>x</code> and <code>y</code> instance variables have been initialized to <code>1</code> and
                  <code>2</code>, respectively. (Assuming that <code>Point.initialize</code> was declared as shown
                  above.)</li>
              </ul>
            </li>
            <li>
              <code>send(recv, selector, arg<sub>1</sub>, arg<sub>2</sub>, &hellip;)</code>
              <ul>
                <li>Looks up the method with the name <code>selector</code> in the class of <code>recv</code> (the
                  <i>receiver</i> of the message), calls the method with the appropriate arguments, and returns the
                  result of that call.</li>
                <li>Throws an exception if <code>recv</code>'s class does not have such a method
                  (<i>message not understood</i>).</li>
                <li>E.g., <code>OO.send(OO.instantiate("Point", 1, 2), "+", OO.instantiate("Point", 3, 4))</code> should
                  evaluate to a new <code>Point</code> whose <code>x</code> and <code>y</code> instance variables are
                  equal to <code>4</code> and <code>6</code>, respectively.</li>
              </ul>
            </li>
            <li>
              <code>superSend(superClassName, recv, selector, arg<sub>1</sub>, arg<sub>2</sub>, &hellip;)</code>
              <ul>
                <li>Looks up the method that corresponds to <code>selector</code> in the class called
                  <code>superClassName</code>, calls it with the appropriate arguments, and returns the result of that
                  call.</li>
                <li>Throws an exception if:
                  <ul>
                    <li>There is no entry in the class table for <code>superClassName</code>
                      (<i>undeclared class</i>).</li>
                    <li>The superclass does not have such a method (<i>message not understood</i>).</li>
                  </ul></li>
                <li>E.g., <code>OO.superSend("Object", myPoint, "initialize")</code></li>
              </ul>
            </li>
            <li>
              <code>getInstVar(recv, instVarName)</code>
              <ul>
                <li>Returns the value of the instance variable called <code>instVarName</code> in
                  <code>recv</code>.</li>
                <li>Throws an exception if <code>recv</code> does not have an instance variable with that name
                  (<i>undeclared instance variable</i>).</li>
                <li>E.g., <code>OO.getInstVar(myPoint, "x")</code>
              </ul>
            </li>
            <li>
              <code>setInstVar(recv, instVarName, value)</code>
              <ul>
                <li>Sets the value of the instance variable called <code>instVarName</code> in <code>recv</code> to
                  <code>value</code> and returns that value.</li>
                <li>Throws an exception if <code>recv</code> does not have an instance variable with that name
                  (<i>undeclared instance variable</i>).</li>
                <li>E.g., <code>OO.setInstVar(myPoint, "x", 5)</code></li>
              </ul>
            </li>
          </ul>
        </p>
        <p>
          These are all of the requirements for your implementation. However, you'll probably want to declare a few
          helper methods to simplify your implementation of the API described above. Here are a couple of ideas to get
          you started:
          <ul>
            <li>
              <code>getClass(name)</code>
              <ul>
                <li>Returns the object that represents the class with the given <code>name</code>.</li>
                <li>Throws an exception if there is no such class (<i>undeclared class</i>).</li>
              </ul>
            </li>
            <li>
              <code>classOf(x)</code>
              <ul>
                <li>Returns the object that represents the class of the object <code>x</code>.</li>
                <li>E.g., <code>OO.classOf(OO.instantiate("Point", 1, 2))</code> should evaluate to the object that
                  represents the <code>Point</code> class.</li>
              </ul>
            </li>
            <li>&hellip;</li>
          </ul>
        </p>
        <h3>Unit Tests for Part I</h3>
        <script src="oo.js"></script>
        <script src="hw4-tests-part1.js"></script>
        <p>
          You can add your own test cases by editing <a href="hw4-tests-part1.js"><code>hw4-tests-part1.js</code></a>.
        </p>
        <h2>Part II: Look ma, no primitives!</h2>
        <p>
          In mainstream "object-oriented" languages like Java and C++, primitive values like <code>5</code> and
          <code>true</code> are not real objects. This is unfortunate because (among other things) it often forces
          programmers to write code in an unnatural way. Here are a couple of examples:
          <ul>
            <li>Isn't it annoying that you can write <code>getAge()</code> as a method of <code>Person</code>, but you
              can't write <code>factorial</code> as a method of <code>int</code>?</li>
            <li>Why is it that primitive types like <code>int</code> are not classes?!?! In Java,
              this means that you can't use them as type parameters of a generic class / interface. For example, you
              can't have a <code>Set&lt;int&gt;</code> &mdash; instead, you're stuck with
              <code>Set&lt;Integer&gt;</code>, i.e., a set of <i>boxed</i> <code>int</code>s. Is this really something
              the programmer should have to deal with?</li>
          </ul>
        </p>
        <p>
          As an aspiring language designer, we hope this lack of uniformity gives you the heebie-jeebies, and we know
          you can do better! It shouldn't matter how an integer is represented at the language implementation level.
          Our job is to help programmers, and we shouldn't expose them to implementation details that make programming
          more complicated than it has to be.
        </p>
        <p>
          In Homework #5, we will make our language into a "pure" object-oriented language, i.e., a language in which
          <i>everything</i> is an object. As we'll see, this has some really nice benefits for the expressiveness of
          the language. OK, you're clearly excited about this&hellip; Alright then, we won't make you wait until
          Homework #5 to get a taste of the pure stuff :)
        </p>
        <p>
          As a first step toward supporting pure OO programming, modify your implementation of the API described above
          so that JavaScript's primitive numbers can be used as first-class objects in your language. For example,
          <code>OO.send(6, "*", 7)</code> should evaluate to <code>42</code>. Here are the changes you'll have to make:
          <ul>
            <li>
              <code>OO.initializeCT()</code> should declare the following classes and methods:
              <ul>
                <li>
                  <code>Object</code>
                  <ul>
                    <li><code>initialize()</code>, <code>===</code>, and <code>!==</code> should work as described
                      previously.</li>
                    <li><code>isNumber()</code> returns <code>false</code></li>
                  </ul>
                </li>
                <li>
                  <code>Number</code> (a subclass of <code>Object</code>)
                  <ul>
                    <li><code>isNumber()</code> returns <code>true</code></li>
                    <li><code>+ anotherNumber</code> returns the sum of the receiver and <code>anotherNumber</code>
                    <li><code>- anotherNumber</code> &hellip;
                    <li><code>* anotherNumber</code> &hellip;
                    <li><code>/ anotherNumber</code> &hellip;
                    <li><code>% anotherNumber</code> &hellip;
                  </ul>
                </li>
              </ul>
            </li>
            <li>
              When <code>typeof recv === "number"</code>,<br>
              <code>OO.send(recv, selector, arg<sub>1</sub>, arg<sub>2</sub>, &hellip;)</code> should look up the
              method with the name <code>selector</code> in the <code>Number</code> class.
            </li>
          </ul>
        </p>
        <h3>Unit Tests for Part II</h3>
        <script src="hw4-tests-part2.js"></script>
        <p>
          You can add your own test cases by editing <a href="hw4-tests-part2.js"><code>hw4-tests-part2.js</code></a>.
        </p>
      </section>
      <section>
        <sectionHeader>
          <span>Homework #5: Completing the Prototype</span>
        </sectionHeader>
        <p>
          <due>
            <b>Due at 11:30pm on Wednesday, March 4.</b>
            Turn in just your <tt>oo.js</tt> file through the course page on CCLE.
          </due>
        </p>
        <p>
          In this homework, you will complete the prototype of our OO language. This will include doing a little more
          work on the library that you implemented for Homework #4, and writing a translator from our OO language to
          JavaScript.
        </p>
        <h2>Part I: Objectifying More Primitives</h2>
        <p>
          Modify <code>OO.initializeCT()</code> to:
          <ul>
            <li>Add <code>&lt;</code>, <code>&leq;</code>, <code>&geq;</code>, and <code>&gt;</code> methods to the
              <code>Number</code> class. These methods should have the same semantics as their corresponding operators
              in JavaScript.</li>
            <li>
              Declare the following classes:
              <ul>
                <li><code>Null</code> (a subclass of <code>Object</code>)</li>
                <li><code>Boolean</code> (a subclass of <code>Object</code>)</li>
                <li><code>True</code> (a subclass of <code>Boolean</code>)</li>
                <li><code>False</code> (a subclass of <code>Boolean</code>)</li>
              </ul>
            </li>
          </ul>
        </p>
        <p>
          <b>Note:</b> The new classes listed above should not have any instance variables. They shouldn't have any
          methods either, though by the time you're done with this assignment, you will be able to declare methods for
          them using the source language, e.g., <codeBlock>def Boolean.isBoolean() { return true; }</codeBlock>
        </p>
        <p>
          Now modify <code>OO.send()</code> so that:
          <ul>
            <li><code>OO.send(null,</code>
              selector<code>, </code>e<sub>1</sub><code>, </code>e<sub>2</sub><code>, &hellip;)</code> looks up the
              appropriate method in the <code>Null</code> class.</li>
            <li>Similarly, when the receiver is <code>true</code> or <code>false</code>, method lookup should happen in
              the <code>True</code> or <code>False</code> class, respectively.</li>
          </ul>
        </p>
        <h3>Unit Tests for Part I</h3>
        <script src="hw5-tests-part1.js"></script>
        <p>
          You can add your own test cases by editing <a href="hw5-tests-part1.js"><code>hw5-tests-part1.js</code></a>.
        </p>
        <h2>Part II: The Translator</h2>
        <p>
          You will now write a translator from our OO language to JavaScript. Some of the features of our language
          (e.g., class declarations) can be translated to a single method call that uses the OO library that you wrote
          in Homework #4. Other features will have to be translated to JavaScript code that has the desired behavior
          &mdash; it will be your job to design an appropriate translation strategy for these features.
        </p>
        <p>
          Source programs will be provided as abstract syntax trees (ASTs) similar to the ones you saw in Homeworks #1
          and #2. Your translator will take an AST as an argument, and return a string containing the JavaScript code
          generated from that AST: <codeBlock>O.transAST = function(ast) {
  // TODO: translate the AST to JavaScript
};</codeBlock>
        </p>
        <p>
          <b>Note:</b> It is important that you store your translation function in <code>O.transAST</code>. This will
          hook it up to our test harness (which will also be used for grading!) and let you use the playground below
          to experiment with your prototype.
        </p>
        <p>
          Similar to the evaluators you wrote in the first two homeworks, it is natural for your translation to be
          compositional. That is, the translation of an expression or statement should be defined in terms of the
          translations of its subparts (other expressions and statements). This leads to a nice recursive solution,
          and it also ensures that you allow the subparts to be themselves arbitrarily complex. For example, the
          arguments to message sends can be arbitrary expressions, including other message sends. Also like those
          earlier homeworks, your implementation will need to "dispatch" on the kind of AST node being considered.
          <i>We strongly encourage you to use the pattern matching library that you wrote in Homework #3 for this
          purpose.</i>
        </p>
        <p>
          The rest of this section shows how the concrete syntax of each of the constructs in our language is
          represented as an AST node. We also explain the semantics of some of the constructs.
        </p>
        <h3>Programs</h3>
        <p>
          The top-level AST node will always represent an entire program. A program in our OO language consists of zero
          or more <i>source elements</i>, each of which may be a class declaration, a method declaration, or a
          statement. The AST node for a program includes the tag <code>"program"</code> followed by the AST nodes for
          the program's source elements: <codeBlock>["program", ast1, ast2, ...]</codeBlock>
        </p>
        <p>
          <b>Hint:</b> The first thing you should generate from a program node is the following statement,
          <codeBlock>OO.initializeCT();</codeBlock>
          that way every time a program is evaluated, it starts with a clean slate.
        </p>
        <h3>Class Declarations</h3>
        <p>
          Class declarations, e.g.,
          <codeBlock>class ThreeDeePoint extends Point with z;</codeBlock>
          are represented as <code>classDecl</code> nodes that include the name of the class that is being declared,
          the name of its superclass, and a list of its instance variable names, e.g.,
          <codeBlock>["classDecl", "ThreeDeePoint", "Point", ["z"]]</codeBlock>
          Note that the name of the superclass is included in the classDecl node even when it's not written explicitly
          in the concrete syntax, e.g.,
          <codeBlock>class Point with x, y;</codeBlock>
          is represented as
          <codeBlock>["classDecl", "Point", "Object", ["x", "y"]]</codeBlock>
        </p>
        <h3>Method Declarations</h3>
        <p>
          Method declarations, e.g.,
          <codeBlock>def C.m(a, b, c) { &hellip; }</codeBlock>
          are represented as <code>methodDecl</code> nodes that include the name of the class in which the method is
          being declared, the name of the method, a list containing the names of its arguments, and a list containing
          the ASTs of the statements in its body, e.g.,
          <codeBlock>["methodDecl", "C", "m", ["a", "b", "c"], [...]]</codeBlock>
        </p>
        <p>
          Note that the result of calling a method that doesn't return a value should be <code>null</code>. E.g., <codeBlock>def Object.m() { }
new Object().m();  // should evaluate to null</codeBlock>
        </p>
        <h3>Statements and Expressions</h3>
        <p>
          <table class="syntax">
            <tr>
              <th></th>
              <th>Concrete Syntax</th>
              <th>JS AST</th>
            </tr>
            <tr>
              <td>s ::=</td>
              <td>
                <multival>
                  <div><code>var </code>x<sub>1</sub><code> = </code>e<sub>1</sub><code>, </code>x<sub>2</sub><code> = </code>e<sub>2</sub><code>, &hellip;;</code></div>
                  <div><code>return </code>e<code>;</code></div>
                  <div>x<code> = </code>e<code>;</code></div>
                  <div><code>this.</code>x<code> = </code>e<code>;</code></div>
                  <div>e<code>;</code></div>
                </multival>
              </td>
              <td>
                <div><code>["varDecls", [</code>x<sub>1</sub><code>, </code>e<sub>1</sub><code>], [</code>x<sub>2</sub><code>, </code>e<sub>2</sub><code>]&hellip;]</code></div>
                <div><code>["return",</code> e<code>]</code></div>
                <div><code>["setVar",</code> x<code>, </code>e<code>]</code></div>
                <div><code>["setInstVar",</code> x<code>, </code>e<code>]</code></div>
                <div><code>["exprStmt",</code> e<code>]</code></div>
              </td>
            </tr>
            <tr>
              <td>e ::=</td>
              <td>
                <multival>
                  <div><code>null</code></div>
                  <div><code>true</code></div>
                  <div><code>false</code></div>
                  <div><code>42</code></i></div>
                  <div>x</div>
                  <div><code>this.</code>x</div>
                  <div><code>new </code>C<code>(</code>e<sub>1</sub><code>, </code>e<sub>2</sub><code>, &hellip;)</code></div>
                  <div>e<sub>recv</sub><code>.</code>m<code>(</code>e<sub>1</sub><code>, </code>e<sub>2</sub><code>, &hellip;)</code></div>
                  <div><code>super.</code>m<code>(</code>e<sub>1</sub><code>, </code>e<sub>2</sub><code>, &hellip;)</code></div>
                </multival>
              </td>
              <td>
                <div><code>["null"]</code></div>
                <div><code>["true"]</code></div>
                <div><code>["false"]</code></div>
                <div><code>["number", 42]</code><sideBar>(For example.)</sideBar></div>
                <div><code>["getVar", </code>x<code>]</code></div>
                <div><code>["getInstVar", </code>x<code>]</code></div>
                <div><code>["new", </code>C<code>, </code>e<sub>1</sub><code>, </code>e<sub>2</sub><code>, &hellip;]</code></div>
                <div><code>["send", </code>e<sub>recv</sub><code>, </code>m<code>, </code>e<sub>1</sub><code>, </code>e<sub>2</sub><code>, &hellip;]</code></div>
                <div><code>["superSend", </code>m<code>, </code>e<sub>1</sub><code>, </code>e<sub>2</sub><code>, &hellip;]</code></div>
              </td>
            </tr>
            <tr>
              <td>x ::=</td>
              <td>an identifier, e.g., <code>sum</code></td>
              <td>a string, e.g., <code>"sum"</code></td>
            </tr>
            <tr>
              <td>C ::=</td>
              <td>a class name, e.g., <code>Point</code></td>
              <td>a string, e.g., <code>"Point"</code></td>
            </tr>
          </table>
        </p>
        <h3>Unit Tests for Part II</h3>
        <script src="hw5-tests-part2.js"></script>
        <p>
          You can add your own test cases by editing <a href="hw5-tests-part2.js"><code>hw5-tests-part2.js</code></a>.
        </p>
        <h2>Part III: Blocks</h2>
        <p>
          Borrowing from <a href="http://en.wikipedia.org/wiki/Smalltalk">Smalltalk</a>, our language also includes <i>blocks</i>, which are essentially an object-oriented
          version of <i>lambdas</i> (a.k.a. first-class functions). Here are some examples:
          <ul>
            <li>a block with no arguments: <code>{1 + 2}</code></li>
            <li>a block with two arguments, <code>x</code> and <code>y</code>: <code>{ x, y | x + y }</code></li>
            <li>a block with one argument whose body consists of multiple statements: <code>{ x | x.m(); x.n(); }</code></li>
          </ul>
        </p>
        <p>
          In general, a block can have any number of declared arguments and its body can consist of any number of
          statements. When the last statement is an expression statement, the semicolon at the end is optional.
        </p>
        <p>
          <table class="syntax">
            <tr>
              <th></th>
              <th>Concrete Syntax</th>
              <th>JS AST</th>
            </tr>
            <tr>
              <td>e ::=</td>
              <td>
                <multival>
                  <div>&hellip;</div>
                  <div><code>{ </code>x<sub>1</sub><code>, </code>x<sub>2</sub><code>, &hellip; | </code>s<sub>1</sub> s<sub>2</sub> &hellip;<code> }</code></div>
                </multival>
              </td>
              <td>
                <div>&hellip;</div>
                <div><code>["block", [</code>x<sub>1</sub><code>, </code>x<sub>2</sub><code>, &hellip;], [</code>s<sub>1</sub><code>, </code>s<sub>2</sub><code>, &hellip;]]</code></div>
              </td>
            </tr>
          </table>
        </p>
        <p>
          You evaluate a block by sending it a <code>call</code> message, to which you can pass the appropriate
          arguments. Unlike in a method body, which requires an explicit <code>return</code> statement, a block
          implicitly returns the value of its last expression statement (i.e., <code>exprStmt</code> node). Here are
          some examples:
          <ul>
            <li><code>{1 + 2}.call()</code> should evaluate to <code>3</code></li>
            <li><code>{ x, y | x * y }.call(6, 7)</code> should evaluate to <code>42</code></li>
            <li><code>{ x | x.m(); x.n(); }.call(someObj)</code> should result in calling <code>someObj</code>'s <code>m</code> method, then <code>someObj</code>'s
              <code>n</code> method, and evaluate to the result of the latter.</li>
          </ul>
        </p>
        <p>
          Just like lambdas, blocks can reference variables from their surrounding scope. A block also acts as kind of
          lexical scope: any variable declarations that are made inside a block are not visible outside it.
          Conveniently, JavaScript's functions have both of these properties&hellip;
        </p>
        <p>
          So you can (and should!) avoid the need to implement the semantics of closures and lexical scopes from scratch
          by translating blocks to plain old JavaScript functions. As with the treatment of numbers and booleans, you
          will need to add a class for blocks (<code>Block</code>) that supports a <code>call</code> method.
        </p>
        <h3>Roll Your Own Control Structures</h3>
        <p>
          You've probably noticed that our language lacks control structures, e.g., it doesn't have <code>if</code> or
          <code>while</code> statements. It turns out we don't need any built-in control structures because it's
          straightforward for programmers to define their own, as ordinary methods. This power comes from a combination
          of <i>purity</i> (the fact that everything in our language is an object) and support for <i>open classes</i>
          (the fact that a programmer can add new methods to any class in the system).
        </p>
        <p>
          For example, an if-then-else "statement" can be defined as a method <code>thenElse</code> on
          <code>Boolean</code>s that takes two blocks as arguments, one for each branch of the conditional. With
          appropriate implementations for the classes <code>True</code> and <code>False</code>, it is now possible to
          write conditionals like the following:<codeBlock>(x >= 0).thenElse(
  { x = 2*x },
  { x = x * -1 })</codeBlock>
          With the syntactic sugar that we saw in class you could write the following expression, which is equivalent
          to the one shown above:<codeBlock>x >= 0 then {
  x = 2*x
} else {
  x = x * -1
}</codeBlock>
        </p>
        <h3>Semantics of <code>return</code> Inside a Block</h3>
        <p>
          As mentioned earlier, a block implicitly returns the value of its last expression statement. Sometimes it is
          more natural for a block to directly return from its enclosing method &mdash; this is especially the case when
          blocks are used to implement control structures. In our language, the <code>return</code> statement inside a
          block acts as such a <i>non-local return</i>. For example, here is an implementation of the absolute value
          method for <code>Number</code>s:<codeBlock>def Number.abs() {
  (this >= 0).thenElse(
    { return this; },
    { return this * -1; })
}</codeBlock>
          When a <code>return</code> statement is executed in the above code, it returns the associated value from the
          <code>abs</code> method itself, and returns control to the caller of <code>abs</code>, rather than just
          returning from the block. While it may seem like there are two different kinds of <code>return</code>
          in our language, this isn't really the case. A <code>return</code> inside a block means exactly the same thing
          as a <code>return</code> inside a method: return this value <i>from (this particular activation of) the
          enclosing method</i>.
        </p>
        <p>
          One interesting issue is how to treat non-local <code>return</code>s in cases where the block is passed around
          before it is called. In our language, it's a run-time error to try to execute a <code>return</code> from a
          block whose enclosing method has already returned. Otherwise, it is OK for a block to execute a
          <code>return</code>, regardless of where on the call stack the enclosing method's activation record is. For
          instance, in the absolute value example above, a <code>return</code> causes the activation records for
          <code>Block</code>'s <code>call</code> method and <code>Boolean</code>'s <code>thenElse</code> method to
          be popped off the stack, and the return value is then associated with the original call to
          <code>Number</code>'s <code>abs</code> method. Here's another example:<codeBlock>def Object.m() {
  var b = { return 5; };
  return this.n(b) * 2;
}

def Object.n(aBlock) {
  aBlock.call();
  return 42;
}

new Object().m();  // evaluates to 5</codeBlock>
        </p>
        <p>
          To implement non-local <code>return</code> properly, the stack must be "walked," popping off stack frames
          until the right activation record is found.  <b>Hint:</b> <i>Exceptions</i> already walk the stack, so it is
          natural to use them to implement non-local returns. The main difficulty is to ensure that a
          <code>return</code> is always associated with the correct method invocation.
        </p>
        <h3>Unit Tests for Part III</h3>
        <script src="hw5-tests-part3.js"></script>
        <p>
          You can add your own test cases by editing <a href="hw5-tests-part3.js"><code>hw5-tests-part3.js</code></a>.
        </p>
      </section>
      <section>
        <sectionHeader>
          <span>Playground</span>
        </sectionHeader>
        <script>

insertPlayground(
    O,
    '6 * 7'
);

        </script>
      </section>
      <section>
        <sectionHeader>
          <span>Extra Credit</span>
        </sectionHeader>
        <p>
          <ul>
            <li>Re-implement this language as an interpreter similar to the one that you wrote for the functional
              language in Homeworks #1 and #2, and write a brief (1-2 page) report comparing the two prototyping styles.
              (It's OK to use your <code>OO</code> library in your interpreter.)</li>
            <li>Modify your implementation so that classes are first-class objects. After this change, a programmer
              should be able to declare new classes and methods dynamically by calling methods on <code>Class</code>
              objects. (Food for thought: what is the superclass of <code>Class</code>?)</li>
            <li>Are there other aspects of this language that could be made into objects? Consider variables, for
              example. If variables were objects, it would make sense for assignment to be a method (even though it
              may not look that way in the syntax). What kinds of interesting things might programmers be able to do
              if they were able to override the assignment operator? Another example is activation records: if they
              were objects, what would it mean to look up the value of a local variable? Lots of opportunities for
              extra-credit projects here!</li>
          </ul>
        </p>
      </section>
      <section>
        <sectionHeader>
          <span>Recommended Reading</span>
        </sectionHeader>
        <p>
          <ul>
            <li>Alan Kay's <a href="http://www.smalltalk.org/downloads/papers/SmalltalkHistoryHOPL.pdf">The Early
              History of Smalltalk</a></li>
            <li>Dan Ingalls' <a href="https://ia601608.us.archive.org/21/items/bitsavers_xeroxparctalk76ProgrammingSystemDesignandImplement_1637358/The_Smalltalk-76_Programming_System_Design_and_Implementation.pdf">The Smalltalk-76
              Programming System Design and Implementation</a></li>
            <li>The first 100 pages or so of Gregor Kiczales et al.'s <a href="http://www.amazon.com/The-Metaobject-Protocol-Gregor-Kiczales/dp/0262610744#">The Art of the Meta-Object Protocol</a></li>
            <li>OOP doesn't necessarily mean "programming with classes". Here are a couple of interesting papers on
              <i>prototype-based</i> OO languages:
              <ul>
                <li>Henry Lieberman's <a href="http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=08215CC8C328830681F432DC19CC3F0C?doi=10.1.1.48.69&rep=rep1&type=pdf">Using Prototypical Objects to Implement Shared Behavior in Object Oriented Systems</a></li>
                <li>David Ungar and Randy B. Smith's <a href="http://www.selflanguage.org/_static/published/self-power.pdf">SELF: The Power of Simplicity</a></li>
              </ul></li>
          </ul>
        </p>
      </section>
    </everything>
  </body>
</html>

